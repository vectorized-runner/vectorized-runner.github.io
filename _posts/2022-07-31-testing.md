Hi, this is my first blog post and I wanted to make it about performance.

Here's the story, while coding the gameplay logic the systems in our game use lots of temporary lists which are discarded by the end of frame. 

If we use the C# list in the System namespace, we create a lot of garbage and the GC has to run frequently. The CPU usage spikes caused by the GC is not acceptable for our games, even if it happens for some frames.

Today I want to talk about list optimizations I've done over time, merged in one data structure which I will call StackOnlyList. 

Here's the aim of this List data structure:

1. Allow using stack allocated memory as initial buffer
2. Fallback to pooled memory if the list needs to grow or the list size needs to be high
3. Should be simple to use and hard to misuse
4. Extra optimizations for working with big structs



Let's start with the signature and fields of our list:

```csharp
public ref struct StackOnlyList<T> where T : IEquatable<T>
{
    // These fields are internal because they're used in unit tests
    internal Span<T> Span;
    internal T[] ArrayFromPool;
    public int Capacity { get; private set; }
    public int Count { get; private set; }

    ...
}
```

The list is a **ref struct**, which allows us to store stack allocated memory, which will be assigned to the **Span** field. **Ref structs** can't escape to the managed heap. For example, you can't cache it on a class field. It's good for our implementation, since our list is only meant to be used for temp memory.

// TODO: Some explanation about Span

**ArrayFromPool** field is to store arrays returned from the shared memory, we'll eventually return the array so we keep a reference to it.

Notice that I've forced generic type *T* to implement the **IEquatable** interface. It's an extra optimization when working with structs, as the default **Equals** implementation causes **boxing**.

Here's the the constructor for stack memory:

```csharp
public StackOnlyList(Span<T> initialBuffer)
{
    ArrayFromPool = null;
    Span = initialBuffer;
    Capacity = initialBuffer.Length;
    Count = 0;
}
```

We can use the constructor like this:

```csharp
// The first 32 items come for free!
// Notice that stackalloc memory is implicitly cast to Span<T> constructor parameter
var list = new StackOnlyList<int>(stackalloc int[32]);
```

You need to be **very careful ** when using this constructor though, you can cause **StackOverFlow** 
