Hi, this is my first blog post and I wanted to make it about performance.

Here's the story, while coding the gameplay logic the systems in our game use lots of temporary lists which are discarded by the end of frame. 

If we use the C# list in the System namespace, we create a lot of garbage and the GC has to run frequently. The CPU usage spikes caused by the GC is not acceptable for our games, even if it happens for some frames.

Today I want to talk about list optimizations I've done over time, merged in one data structure which I will call StackOnlyList. 

Here's the aim of this List data structure:

1. Allow using stack allocated memory as initial buffer
2. Fallback to pooled memory if the list needs to grow or the list size needs to be high
3. Should be simple to use and hard to misuse
4. Extra optimizations for working with big structs



Let's start with the signature and fields of our list:

```csharp
public ref struct StackOnlyList<T> where T : IEquatable<T>
{
    // These fields are internal because they're used in unit tests
    internal Span<T> Span;
    internal T[] ArrayFromPool;
    public int Capacity { get; private set; }
    public int Count { get; private set; }

    ...
}
```

The list is a [ref struct]( **https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#ref-struct**), which allows us to store stack allocated memory, which will be assigned to the [Span](https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=net-6.0) field. **Ref structs** can't escape to the managed heap. For example, you can't cache it on a class field. It's good for our implementation, since our list is only meant to be used for temp memory.

**ArrayFromPool** field is to store arrays returned from the shared memory, we'll eventually return the array so we keep a reference to it.

Notice that I've forced generic type *T* to implement the **IEquatable** interface. It's an extra optimization when working with structs, as the default **Equals** implementation causes **boxing** for structs.

Here's the the constructor for stack memory:

```csharp
public StackOnlyList(Span<T> initialBuffer)
{
    ArrayFromPool = null;
    Span = initialBuffer;
    Capacity = initialBuffer.Length;
    Count = 0;
}
```

We can use the constructor like this:

```csharp
// The first 32 items come for free!
// Notice that stackalloc memory is implicitly cast to Span<T> constructor parameter
var list = new StackOnlyList<int>(stackalloc int[32]);
```

You need to be **very careful ** when using this constructor though.

```cs
// This method may crash your program depending on the 'size' parameter and the size of the generic type T. If the size is a parameter you shouldn't use this constructor!
void PotentiallyDangerousMethod(int size)
{
    var list = new StackOnlyList<int>(stackalloc int[size]);
}

// Calling this method will throw StackOverflowException, but you can't even catch it (with a try/catch block), it's going to crash your program!
void DefinitelyDangerousMethod()
{
    for(int i = 0; i < 100_000; i++)
    {
        var list = new StackOnlyList<int>(stackalloc int[32]);
        list.Add(0);
        list.Add(0);
        list.Add(0);
    }
}

// This method is safe, as each call to TempListAdd will release the stackalloc memory before the next one is called.  
void SafeMethod()
{
    for(int i = 0; i < 100_000; i++)
    {
        TempListAdd();
    }
}

void TempListAdd()
{
    var list = new StackOnlyList<int>(stackalloc int[32]);
    list.Add(0);
    list.Add(0);
    list.Add(0);  
}
```

As you can see, there are some pitfalls, but that's ok as long as we know what we're doing.

Now, let's see the *safe* constructor:

```csharp
public StackOnlyList(int initialCapacity = 0)
{
	switch(initialCapacity)
	{
		case < 0:
		{
			throw new InvalidOperationException("Capacity can't be negative.");
		}
		case 0:
		{
			ArrayFromPool = null;
			Span = null;
			Capacity = 0;
			Count = 0;
			break;
		}
		case > 0:
		{
			ArrayFromPool = ArrayPool<T>.Shared.Rent(initialCapacity);
			Span = ArrayFromPool;
			Capacity = initialCapacity;
			Count = 0;
			break;
		}
	}
}
```

